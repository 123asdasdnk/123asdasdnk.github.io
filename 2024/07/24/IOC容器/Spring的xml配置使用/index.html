<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring的xml配置使用 | 花火の绽放</title><meta name="author" content="業火の 向日葵"><meta name="copyright" content="業火の 向日葵"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这里填写摘要。也可以把摘要这一段删去，在文章中想要截断的地方加入，这样在首页就只显示开头到截断的内容，而不会显示全文">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring的xml配置使用">
<meta property="og:url" content="https://123asdasdnk.github.io/2024/07/24/IOC%E5%AE%B9%E5%99%A8/Spring%E7%9A%84xml%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="花火の绽放">
<meta property="og:description" content="这里填写摘要。也可以把摘要这一段删去，在文章中想要截断的地方加入，这样在首页就只显示开头到截断的内容，而不会显示全文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://123asdasdnk.github.io/image/%E9%AC%BC%E5%88%80.jpg">
<meta property="article:published_time" content="2024-07-23T16:16:38.954Z">
<meta property="article:modified_time" content="2024-07-23T16:20:14.269Z">
<meta property="article:author" content="業火の 向日葵">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="IOC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://123asdasdnk.github.io/image/%E9%AC%BC%E5%88%80.jpg"><link rel="shortcut icon" href="/image/icon.png"><link rel="canonical" href="https://123asdasdnk.github.io/2024/07/24/IOC%E5%AE%B9%E5%99%A8/Spring%E7%9A%84xml%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring的xml配置使用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-24 00:20:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/source/css/transpancy.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/%E9%AC%BC%E5%88%80.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="花火の绽放"><img class="site-icon" src="/image/icon.png"/><span class="site-name">花火の绽放</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring的xml配置使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-23T16:16:38.954Z" title="发表于 2024-07-24 00:16:38">2024-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-23T16:20:14.269Z" title="更新于 2024-07-24 00:20:14">2024-07-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring的xml配置使用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Spring不仅由xml的使用方式还有注解的使用方式，是不是就像mybatis?</p>
<p>这次先详细讲解一下xml的使用，注意是使用，还有底层原理要到后面才学，</p>
<p>xml配置与注解使用相比，有很多说法：</p>
<p>有人说注解好，因为注解简洁很方便，如果用xml配置的话太麻烦了<br>也有人说xml配置好，因为xml配置非常清楚，如果用注解，有些地方会很模糊</p>
<p>也是仁者见仁，智者见智</p>
<p>其实在后面的SpringBoot开发中，注解是经常使用的</p>
<h1 id="一、前置操作"><a href="#一、前置操作" class="headerlink" title="一、前置操作"></a>一、前置操作</h1><p>创建完项目后导入Spring依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>成功导入后会显示：</p>
<p>![[Pasted image 20240709151844.png]]</p>
<hr color= "green">

<h1 id="二、xml使用"><a href="#二、xml使用" class="headerlink" title="二、xml使用"></a>二、xml使用</h1><p>如果使用xml，那么需要再resource文件夹中创建对应的配置文件(如：SpringConfig.xml)</p>
<p>![[Pasted image 20240709152038.png]]</p>
<p>配置文件中写入如下内容：</p>
<p>之后注册类什么的都写再这里面了(有点像面对xml编程了hhh)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>*写入之后，会显示这个，然后配置应用程序上下文（当然不搞也不会报错，只是一些Spring的图标不会显示）</p>
<p>![[Pasted image 20240709152245.png]]</p>
<hr>
<h2 id="2-1-开始创建ApplicationContext"><a href="#2-1-开始创建ApplicationContext" class="headerlink" title="2.1 开始创建ApplicationContext"></a>2.1 开始创建ApplicationContext</h2><p>ApplicationContext是应用程序上下文的顶层接口，它有很多种实现，</p>
<p>可以看到有：</p>
<ul>
<li>ClassPathXmlApplicationContext       *对应 类路径xml文件</li>
<li>AnnotationConfigApplicationContext   *对应 注解配置</li>
</ul>
<p>![[Pasted image 20240709152710.png]]</p>
<p>由于我们这是先介绍xml<br>所以，<em>我们使用ClassPathXmlAppllicationContext来实现</em>我们的ApplicationContext</p>
<p>![[Pasted image 20240709153039.png]]</p>
<p>注意里面的参数就写上Spring配置文件的路径就可以了</p>
<p>创建完应用程序上下文实例，我们就可以通过它来管理我们各种各样的实现类了(不用自己手动new，而是通过这个对象来获取)</p>
<p>举个例子：</p>
<p>先创建一个学生类：</p>
<p>![[Pasted image 20240709153945.png]]</p>
<p>如果我们要获取这个学生对象，那么传统的方式，是不是就是直接new一个： Student s &#x3D; new Student();<br>但是现在我们有更好的方式：<em>通过IoC容器来获取(应用程序上下文对象)</em><br>我们先把这个类注册到xml文件中：</p>
<p>![[Pasted image 20240709162238.png]]</p>
<p>回到Student类：<br>发现会有一个Spring的叶子标志，说明我们注册成功了</p>
<p>![[Pasted image 20240709154415.png]]</p>
<p>现在，这个对象不需要我们再去创建了，而是由IoC容器自动进行创建并提供，我们可以直接从上下文中获取到它为我们创建的对象</p>
<p>我们通过IoC容器获取Student对象：（写法是不是很像mybatis获取mapper对象(Mapper.class)?）</p>
<p>![[Pasted image 20240709154603.png]]</p>
<p>运行结果：<br>![[Pasted image 20240709154623.png]]</p>
<p>可以看到，确实通过IoC容器获取到了Student对象（这里的对象是通过反射机制获取的，）</p>
<p>实际上，这里得到的Student对象是由Spring通过<em>反射机制</em>帮助我们创建的，初学者会非常疑惑，为什么要这样来创建对象，我们直接new一个它不香吗？为什么要交给IoC容器管理呢？在后面的学习中，我们再慢慢进行体会。</p>
<p><img src="https://image.itbaima.cn/markdown/2022/11/22/sjLiFokU1f3CvH5.png" alt="image-20221122153946251"></p>
<hr>
<h2 id="2-2-Bean注册和配置"><a href="#2-2-Bean注册和配置" class="headerlink" title="2.2 Bean注册和配置"></a>2.2 Bean注册和配置</h2><p>上面一节，我们通过一个简单的例子知道了怎么通过IoC容器来获取一个类的实例，当然这还是非常基础的，我们要进行更深层次的学习</p>
<p>这节课我们就来详细了解一下如何向Spring注册Bean以及Bean的相关配置。</p>
<h3 id="2-2-1实际上我们的配置文件可以有很多个，并且这些配置文件是可以相互导入的："><a href="#2-2-1实际上我们的配置文件可以有很多个，并且这些配置文件是可以相互导入的：" class="headerlink" title="2.2.1实际上我们的配置文件可以有很多个，并且这些配置文件是可以相互导入的："></a>2.2.1实际上我们的配置文件可以有很多个，并且这些配置文件是可以相互导入的：</h3><p>像这样：</p>
<p>![[Pasted image 20240709155646.png]]<br>![[Pasted image 20240709155724.png]]</p>
<p>我们这里就让SpringConfig2.xml导入SpringConfig.xml文件</p>
<p>![[Pasted image 20240709155859.png]]</p>
<p>这时候，如果我们创建SpringConfig.xml的上下文会怎么样:</p>
<p>因为我们之前是把Student注册到SpringConfig.xml中的而不是，SpringConfig2.xml中，现在还能不能成功的获取Student对象？</p>
<p>![[Pasted image 20240709155946.png]]</p>
<p>运行结果：</p>
<p>发现成功了，<br><em>这是不是就说明SpringConfig2.xml导入SpringConfig.xml是不是会把SpringConfig.xml文件里面的内容都导入过来</em>（是不是非常像类的继承）</p>
<p>![[Pasted image 20240709160058.png]]</p>
<p>这些配置文件可以创建多个并且可以相互导入有什么用呢？</p>
<p>我认为，这样可以更好的进行文件分类之类的，<br>比如：<br>实体类可以写一个SpringConfig.xml<br>Service接口实现类也可以写一个SpringConfig.xml<br>![[Pasted image 20240709160719.png]]</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring框架允许你创建多个配置文件，并且这些配置文件可以通过`&lt;import&gt;`标签相互导入。这样做可以有效地将配置分散到不同的文件中，便于管理和维护。例如，你可以有一个主配置文件，然后导入其他专门负责特定组件或功能的配置文件。这样可以提高代码的可读性和可维护性。</span><br></pre></td></tr></table></figure>


<p>可以看这篇文章：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58058653/article/details/121170141">【Spring】多个spring配置文件_spring context 多个-CSDN博客</a></p>
<h3 id="2-2-2-bean注册"><a href="#2-2-2-bean注册" class="headerlink" title="2.2.2 bean注册"></a>2.2.2 bean注册</h3><p>什么是bean:</p>
<p><em>高内聚，低耦合，是现代软件的开发的设计目标，而Spring框架就给我们提供了这样的一个IoC容器进行对象的的管理，*<em>一个由Spring IoC容器实例化、组装和管理的对象，我们称其为Bean。</em></em></p>
<p>为了简单起见，我们还是从单配置文件开始讲起，首先我们需要知道如何配置Bean并注册。</p>
<p><em>要注册bean只需要添加bean标签：</em></p>
<p>可以写成单标签:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以是双标签：后面会用到</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是这样写的话，Spring无法得知我们要配置的Bean到底是哪一个类，所以说我们还得指定对应的类才可以</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们就以单标签为例:</p>
<p>之前我们创建了一个Student类，我们把它注册到配置文件中：</p>
<p>![[Pasted image 20240709162624.png]]</p>
<p>成功注册为bean后，会显示一个Spring叶子图标，这样就说明注册成功了<br>![[Pasted image 20240709162829.png]]</p>
<p>我们就可以通过IoC容器来获取对应的实例对象了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> context.getBean(Student.class);</span><br></pre></td></tr></table></figure>

<p>![[Pasted image 20240709163002.png]]</p>
<p>当然也可以不用Student.class：</p>
<p>我们可以再注册bean的时候，为bean标签添加一个属性name(其实就是起一个名字，html里面是不是也有对吧)</p>
<p>![[Pasted image 20240709163234.png]]</p>
<p>这时候我们就可以利用bean名字来进行创建实例了：</p>
<p><em>只不过这时候，就要进行强制类型转化，因为getBean()这时候返回的就是一个Object对象了,需要我们手动强制类型转化一次</em></p>
<p>![[Pasted image 20240709163357.png]]</p>
<p><em><strong>不过在有些时候，Bean的获取可能会出现歧义，我们可以来分别注册两个子类的Bean：</strong></em></p>
<p>先创建两个类ArtStudent和SportStudent并且都继承Student</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArtStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">art</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我爱画画&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SportStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sport</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我爱运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>如果只把ArtStudent与SportStudent注册，Student不注册</em></p>
<p>![[Pasted image 20240709164801.png]]</p>
<p>如果这时候，我要获取父类Student的对象：<br>(如果父类没有注册，只是注册了子类，那么如果要获取父类的实例，那么会找子类)</p>
<p>(<em>这时候我们用类(Student.class)来获取而不是name(“student”)</em>)<br>你猜能不能获取到，</p>
<p>![[Pasted image 20240709171326.png]]</p>
<p>发现报错了<br>![[Pasted image 20240709171243.png]]</p>
<p>这里出现了一个**Bean定义不唯一异常，很明显，因为我们需要的类型是Student，但是此时有两个Bean定义都满足这个类型，它们都是Student的子类，此时IoC容器不知道给我们返回哪一个Bean，所以就只能抛出异常了。</p>
<p>如果用name来访问呢？</p>
<p>![[Pasted image 20240709171605.png]]</p>
<p>![[Pasted image 20240709171554.png]]</p>
<p>![[Pasted image 20240709171623.png]]</p>
<p>发现，显示No bean named ‘student’ available<br>这是因为，在我们注册的bean中，没有bena的name叫student<br>![[Pasted image 20240709171726.png]]</p>
<p><em>因此，如果我们需要一个Bean并且使用类型进行获取，那么必须要指明类型并且不能出现歧义</em><br>知道这个就可以了，理解这句话，怎么搞都不会出错</p>
<p>那要是两个Bean的类型都是一样的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=<span class="string">&quot;com.test.bean.Student&quot;</span>/&gt;</span><br><span class="line">&lt;bean class=<span class="string">&quot;com.test.bean.Student&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>这种情况下，就无法使用Class来进行区分了，除了为Bean指定对应类型之外，我们也可以为Bean指定一个名称(name)用于区分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;art&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.ArtStudent&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;sport&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.SportStudent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>name属性就是为这个Bean设定一个独一无二的名称（id属性也可以，跟name功能相同，但是会检查命名是否规范，否则会显示黄标），不同的Bean名字不能相同，否则报错：</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Student&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Student&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，这两个Bean我们就可以区分出来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">student.hello();</span><br></pre></td></tr></table></figure>

<p><em>虽然目前这两Bean定义都是一模一样的，也没什么区别，但是这确实是两个不同的Bean，只是类型一样而已，之后我们还可以为这两个Bean分别设置不同的其他属性。</em></p>
<p>我们可以给Bean起名字，也可以起别名，就行我们除了有一个名字之外，可能在家里还有自己的小名：<br>(额外多加一个alias标签)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;beanname&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;小名&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Student&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们使用别名也是可以拿到对应的Bean的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">student.hello();</span><br></pre></td></tr></table></figure>

<hr>
<p>我们现在知道了用name访问和用.class来访问的区别了</p>
<p><em>使用name访问：</em></p>
<ul>
<li>如果注册的bean中没有叫这个name，就会报错：No bean named ‘student’ available</li>
</ul>
<p>*使用alias访问:</p>
<ul>
<li>同上</li>
</ul>
<p><em>使用.class来访问：</em></p>
<ul>
<li><p>如果这个类被注册了，要通过IoC容器获取父类本身实例(getBean(父类.class))，那么这个父类绝对不能有子类注册</p>
</li>
<li><p>如果这个类没有被注册，且子类也没有注册,那么通过IoC容器获取这个父类实例(getBean(父类.class))，会报错:<br>No qualifying bean of type ‘com.example.test.Student’ available</p>
</li>
<li><p><em>如果这个类没有被注册，但是有子类注册，要通过IoC容器获取这个父类实例(getBean(父类.class))，那么会创建子类实例来作为父类实例</em>(<strong>但是只能有一个子类注册，多个子类注册会报错：bean定义不唯一</strong>)(就是说，父类不注册，子类注册，要想通过IoC容器获取到父类实例，那么子类注册只能由一个，多个会报错)</p>
</li>
</ul>
<hr>
<p><em>因此，如果我们需要一个Bean并且使用类型进行获取，那么必须要指明类型并且不能出现歧义</em></p>
<hr>
<h3 id="2-2-3那么现在又有新的问题了，IoC容器创建的Bean是只有一个还是每次索要的时候都会给我们一个新的对象？我们现在在主方法中连续获取两次Bean对象："><a href="#2-2-3那么现在又有新的问题了，IoC容器创建的Bean是只有一个还是每次索要的时候都会给我们一个新的对象？我们现在在主方法中连续获取两次Bean对象：" class="headerlink" title="2.2.3那么现在又有新的问题了，IoC容器创建的Bean是只有一个还是每次索要的时候都会给我们一个新的对象？我们现在在主方法中连续获取两次Bean对象："></a>2.2.3那么现在又有新的问题了，IoC容器创建的Bean是只有一个还是每次索要的时候都会给我们一个新的对象？我们现在在主方法中连续获取两次Bean对象：</h3><p>![[Pasted image 20240709174626.png]]</p>
<p>![[Pasted image 20240709175209.png]]</p>
<p>结果为：发现，每次获取的实例，都是同一个，这是因为</p>
<p>![[Pasted image 20240709175231.png]]</p>
<p><em>我们发现，最后得到的结果为true，那么说明每次从IoC容器获取到的对象，始终都是同一个，默认情况下，通过IoC容器进行管理的Bean都是单例模式的，这个对象只会被创建一次。</em></p>
<p>如果我们希望每次拿到的对象都是一个新的，我们也可以将其作用域进行修改：</p>
<p>scope默认为singleton(单例模式)<br><img src="https://image.itbaima.cn/markdown/2022/11/22/hDGo7m9uBlgVn5A.png" alt="image-20221122175719997"></p>
<p>这里一共有两种作用域，第一种是<code>singleton</code>，默认情况下就是这一种，当然还有<code>prototype</code>，表示为原型模式（为了方便叫多例模式也行）这种模式每次得到的对象都是一个新的：</p>
<p><em>singleton为单例模式，prototype是多例模式(原型模式)</em></p>
<p>换成多例模式(原型模式)<br>![[Pasted image 20240709175714.png]]</p>
<p>![[Pasted image 20240709175748.png]]<br>发现，已经不在是同一个对象了</p>
<hr>
<ul>
<li><p>实际上，当Bean的作用域为单例模式时，那么它会在一开始（容器加载配置时）就被创建(是不是很像static的静态加载)，我们之后拿到的都是这个对象。</p>
</li>
<li><p>而处于原型模式下，只有在获取时才会被创建，</p>
</li>
</ul>
<p><em>也就是说，单例模式下，Bean会被IoC容器存储，只要容器没有被销毁，那么此对象将一直存在，而原型模式才是相当于在要用的时候直接new了一个对象，并不会被保存。</em></p>
<ul>
<li>单例模式下，默认bean一开始就加载，原型模式下，获取时才会创建</li>
</ul>
<p>如果想让单例模式下，要让bean获取时才加载，看下面</p>
<hr>
<p>当然，<em>如果我们希望单例模式下的Bean不用再一开始就加载，而是一样等到需要时再加载</em>（<strong>加载后依然会被容器存储，之后一直使用这个对象了，不会再创建新的</strong>）我们也可以<em>开启懒加载</em>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认为单例模式，lazy-init默认为false</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>开启懒加载后，只有在真正第一次使用时才会创建对象。</em></p>
<hr>
<p>因为单例模式下Bean是由IoC容器加载，但是加载顺序我们并不清楚，<em>如果我们需要维护Bean的加载顺序（比如某个Bean必须要在另一个Bean之前创建</em>）那么我们可以使用<code>depends-on</code>来设定前置加载Bean，这样被依赖的Bean一定会在之前加载，比如Teacher应该在Student之前加载：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Teacher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Student&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;teacher&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以保证Bean的加载顺序了。</p>
<hr>
<h2 id="2-3-依赖注入"><a href="#2-3-依赖注入" class="headerlink" title="2.3 依赖注入"></a>2.3 依赖注入</h2><p>依赖注入(Dependency Injection, DI)是一种设计模式，也是Spring框架的核心概念之一。</p>
<p>分为两种：</p>
<ul>
<li>Setter依赖注入：通过成员属性对应的set方法完成注入。<br>（<em>可以使用lombok的@Data 就可以不写set方法</em>）</li>
<li>构造方法依赖注入：通过构造方法完成注入。<br>(<em>可以使用lombok的@AllArgsConstructor，就可以不写构造方法</em>)<br>（其实就是利用property标签 在Setter方法里面进行初始化变量，或者在构造方法里面进行初始化变量）<br>注意：<br>用set依赖注入，要有set方法，并且不能有构造方法</li>
</ul>
<h3 id="2-3-1-Setter依赖注入-在set方法里面进行初始化变量"><a href="#2-3-1-Setter依赖注入-在set方法里面进行初始化变量" class="headerlink" title="2.3.1 Setter依赖注入(在set方法里面进行初始化变量)"></a>2.3.1 Setter依赖注入(在set方法里面进行初始化变量)</h3><p>现在我们已经了解了如何注册和使用一个Bean，但是这样还远远不够，还记得我们一开始说的，消除类之间的强关联吗？比如现在有一个教师接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的实现有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArtTeacher</span> <span class="keyword">implements</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是美术老师，我教你画画！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProgramTeacher</span> <span class="keyword">implements</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是编程老师，我教你学Golang！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的学生一开始有一个老师教他，比如美术老师：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArtTeacher</span>();   </span><br><span class="line">  	<span class="comment">//在以前，如果我们需要制定哪个老师教我们，直接new创建对应的对象就可以了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        teacher.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们发现，如果美术老师不教了，现在来了一个其他的老师教学生，那么就需要去修改Student类的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProgramTeacher</span>();</span><br><span class="line">  	...</span><br></pre></td></tr></table></figure>

<p>可以想象一下，如果现在冒出来各种各样的类都需要这样去用Teacher，那么一旦Teacher的实现发生变化，会导致我们挨个对之前用到Teacher的类进行修改，这就很难受了。（赋值如果要变，那么就要大改）</p>
<p><em>而有了依赖注入之后</em></p>
<p><em>Student中的Teacher成员变量，可以由IoC容器来选择一个合适的Teacher对象进行赋值</em>，也就是说，IoC容器在创建对象时，需要将我们预先给定的属性注入到对象中，非常简单，我们可以使用<code>property</code>标签来实现，我们将bean标签展开：（之前写的bean是单标签，这里bean标签里面还要写的东西所以要用双标签了）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们使用property标签来实现依赖注入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ArtTeacher&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span> &gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;teacher&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--name后面的teacher是实体类中的属性，而ref后面的teacher是实体类注册bean的名字--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--意思就是，默认把Student类中的teacher属性通过set方法赋值为ArtTeacher实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>            |
            |
            |
            V
</code></pre>
<p><em>如果怕搞混可以这么看：</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;art&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ArtTeacher&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span> &gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;art&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>![[Pasted image 20240710154558.png]]</p>
<p><em>同时我们还需要修改一下Student类，依赖注入要求对应的属性必须有一个set方法：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">  	<span class="comment">//要使用依赖注入，我们必须提供一个set方法（无论成员变量的访问权限是什么）命名规则依然是驼峰命名法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTeacher</span><span class="params">(Teacher teacher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>成功注入依赖后，set方法会显示这个黄色加叶子图标<br>![[Pasted image 20240710154953.png]]</p>
<p>使用<code>property</code>来指定需要注入的值或是一个Bean，这里我们选择ArtTeacher</p>
<p>现在我们来创建一个Student对象，看它的teacher是否初始化为了ArtTeacher</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> context.getBean(Student.class);</span><br><span class="line">student.study();</span><br></pre></td></tr></table></figure>

<p>可以看到，teacher确实被初始化为了ArtTeacher</p>
<p>![[Pasted image 20240710155609.png]]</p>
<p>如果这时候，我要把ArtTeacher改为ProgramTeacher只需要：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ProgramTeacher&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--只需要把ArtTeacher变为ProgramTeacher就可以了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span> &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;teacher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果看着混乱可以这么看：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;program&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ProgramTeacher&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span> &gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;program&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是就是之前的那种易懂写法</p>
<p>修改这里即可，我们就可以直接运行了：<br>可以看到，已经变了ProgramTeacher了<br>![[Pasted image 20240710160105.png]]</p>
<p><strong>可以看到，现在我们的Java代码中，没有出现任何的具体实现类信息（ArtTeacher、ProgramTeacher都没出现）取而代之的是那一堆xml配置，这样，就算我们切换老师的实现为另一个类，也不用去调整代码，只需要变动一下Bean的类型就可以</strong></p>
<p>通过依赖注入，是不是开始逐渐感受到Spring为我们带来的便利了？当然，依赖注入并不一定要注入其他的Bean，也可以是一个简单的值：</p>
<p>我们在写property的时候，是不是会发现有一个ref(这是引用，里面写类bean)<br>还有一个是value(这里值，可以写常量，就是把常量赋给实体类里面对应的属性)<br>![[Pasted image 20240710160415.png]]</p>
<p>举个例子：<br>这里，我们为Student类多加一个name属性(必须添加一个set方法)<br>![[Pasted image 20240710160914.png]]</p>
<p>注入set依赖:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ProgramTeacher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;teacher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里我们利用value来为name绑定一个常量小明--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注意了，写哪个类的注入依赖，property标签就要写在哪个类里面的bean标签里--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行：<br>![[Pasted image 20240710161323.png]]<br>是不是小明被成功赋值给了Student的name属性<br>![[Pasted image 20240710161338.png]]</p>
<p>*但是注意，一个property标签只能有ref和value其中的一个</p>
<p>![[Pasted image 20240710160648.png]]</p>
<hr>
<h3 id="2-3-2-构造方法依赖注入-就是在构造方法中初始化变量"><a href="#2-3-2-构造方法依赖注入-就是在构造方法中初始化变量" class="headerlink" title="2.3.2 构造方法依赖注入(就是在构造方法中初始化变量)"></a>2.3.2 构造方法依赖注入(就是在构造方法中初始化变量)</h3><p>实际上，在很多情况下，<em>类中的某些参数是在构造方法中就已经完成的初始化，而不是创建之后</em>（也就是说，现在不是通过set方法进行初始化，而是通过构造方法来进行初始化,这时候，不能使用property标签而是使用<em>constructor-arg标签</em>）<br>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Teacher teacher;   <span class="comment">//构造方法中完成，所以说是一个final变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(Teacher teacher)</span>&#123;   <span class="comment">//Teacher属性是在构造方法中完成的初始化</span></span><br><span class="line">        <span class="built_in">this</span>.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        teacher.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们前面说了，Bean实际上是由IoC容器进行创建的，但是现在我们修改了默认的无参构造，可以看到配置文件里面报错了：</p>
<p>![[Pasted image 20240710164001.png]]</p>
<p>很明显，是因为我们修改了构造方法，IoC容器默认只会调用无参构造，所以，我们需要指明一个可以用的构造方法，我们展开bean标签，添加一个<code>constructor-arg</code>标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ArtTeacher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;teacher&quot;</span>/&gt;</span>  </span><br><span class="line">          <span class="comment">&lt;!--将Student类里面的teacher属性，通过构造方法赋值为ArtTeacher实例--&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--其实跟propertry的用法一样--&gt;</span></span><br><span class="line">          </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>constructor-arg</code>就是构造方法的一个参数，这个参数可以写很多个，会<em>自动匹配符合里面参数数量</em>的构造方法，这里匹配的就是我们刚刚编写的需要一个参数的构造方法。</p>
<p>运行：发现成功获取到了teacher被初始化为ArtTeacher的student实例(这个报错是开头提到了引入一个版本过时问题)</p>
<p>![[Pasted image 20240710164859.png]]</p>
<p>解决版本问题后的运行结果：<br>![[Pasted image 20240710165253.png]]</p>
<p>这里的<code>constructor-arg</code>就是构造方法的一个参数，这个参数可以写很多个，会<em>自动匹配符合里面参数数量的构造方法</em>，这里匹配的就是我们刚刚编写的需要一个参数的构造方法。</p>
<p>这里我们再写一个三个参数的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ArtTeacher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;teacher&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>写三种构造方法：</p>
<p>![[Pasted image 20240710170104.png]]</p>
<p>运行：<br>发现，确实会自动寻找参数个数相同的构造方法<br>![[Pasted image 20240710170127.png]]</p>
<p>再想想：</p>
<ul>
<li><em>如果构造方法的没有三个的：</em></li>
</ul>
<p>![[Pasted image 20240710170316.png]]</p>
<p>就会报错：<br>![[Pasted image 20240710170548.png]]</p>
<p>![[Pasted image 20240710170326.png]]</p>
<ul>
<li>*如果构造方法参数数量可以对应上，但是种类对不上</li>
</ul>
<p>我们两个参数的构造方法对应的参数为teacher和name<br>![[Pasted image 20240710170810.png]]</p>
<p>但是，配置中写的却是：teacher和age</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;teacher&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果还是会报错：<br>![[Pasted image 20240710170934.png]]</p>
<p>如果：</p>
<p>构造方法只有这个3个参数的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(Teacher teacher, String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.teacher = teacher;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，依赖注入里面只要两个参数：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;teacher&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么还是会报错：<br>![[Pasted image 20240710171539.png]]</p>
<p><em>所以说：如果我们再配置中写了对应的构造方法依赖注入，那么一定要让实体类中的构造方法的参数种类和数量都要满足依赖注入的(实体类中的构造方法的参数与依赖注入的参数一一对应，不能多，也不能少，一定要完全一样)</em></p>
<p>还要再想想：</p>
<p>如果是这种情况呢？</p>
<p>现在我们的Student类中是这样定义的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;110&quot;</span>/&gt;</span></span><br><span class="line">小知识，如果只有一个参数，那么可以不写对应实体类的属性(name=&quot;实体类属性&quot;)，会默认找第一个符合要求的</span><br></pre></td></tr></table></figure>


<p>就是构造方法的参数个数都是一个，但是类型不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一号构造方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是二号构造方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = String.valueOf(age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下：<br>是直接找第一个符合的构造方法<br>![[Pasted image 20240710172606.png]]</p>
<p>但是此时我们希望使用的是二号构造方法，那么怎么才能指定呢？有2种方式，我们可以给标签添加类型：</p>
<ul>
<li><em>法一</em>:指定参数类型 用type来指定参数的类型(type&#x3D;”参数类型”)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;110&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>![[Pasted image 20240710172418.png]]</p>
<ul>
<li><em>法二</em>：指定为对应的参数名称：（这就是平常的写法）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;110&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>![[Pasted image 20240710172455.png]]</p>
<p><em>反正只要能够保证我们指定的参数匹配到目标构造方法即可。</em></p>
<ul>
<li><em>现在我们的类中出现了一个比较特殊的类型，它是一个集合类型：</em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这种集合类型，有着特殊的支持：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Student&quot;</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--  对于集合类型，我们可以直接使用标签编辑集合的默认值  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不仅仅是List，Map、Set这类常用集合类包括数组在内，都是支持这样编写的，比如Map类型，我们也可以使用<code>entry</code>来注入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;语文&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;数学&quot;</span> <span class="attr">value</span>=<span class="string">&quot;80.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;英语&quot;</span> <span class="attr">value</span>=<span class="string">&quot;92.5&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>至此，我们就已经完成了两种依赖注入的学习：</p>
<ul>
<li>Setter依赖注入：通过成员属性对应的set方法完成注入。</li>
<li>构造方法依赖注入：通过构造方法完成注入。</li>
</ul>
<hr color="green">

<h2 id="2-4-自动装配"><a href="#2-4-自动装配" class="headerlink" title="2.4 自动装配"></a>2.4 自动装配</h2><p>Spring的自动装配（Automatic Wiring）是一种简化依赖注入的方式，它允许Spring容器自动将一个对象需要的依赖（比如其他对象、服务、资源等）注入到这个对象中，而不需要显式地编写代码来配置这些依赖关系。</p>
<p>在之前，如果我们需要使用set依赖注入的话，我们需要对<code>property</code>参数进行配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;teacher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是有些时候为了方便，我们也可以<em>开启自动装配</em>。自动装配就是让IoC容器自己去寻找需要填入的值，我们只需要将set方法提供好就可以了，这里需要添加<em>autowire</em>属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ArtTeacher&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>autowire</code>属性有两个值普通，一个是<em>byName</em>，还有一个是<em>byType</em>，<br>顾名思义，<br>一个是根据类型去寻找合适的Bean自动装配，<br>一个是根据名字去找，这样我们就不需要显式指定<code>property</code>了。</p>
<p><em>自动装配成功后会再对应的set方法上面生成一个叶子箭头图标</em><br>![[Pasted image 20240710215103.png]]</p>
<p>这样同样可以完成自动注入：</p>
<p>![[Pasted image 20240710215246.png]]</p>
<ul>
<li><em>自动化的东西虽然省事，但是太过机械，有些时候，自动装配可能会遇到一些问题，比如出现了下面的情况：</em></li>
</ul>
<p>就是自动装配的bean有多个，而不是唯一的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ArtTeacher&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ProgramTeacher&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>![[Pasted image 20240710215452.png]]</p>
<p>此时，由于<code>autowire</code>的规则为byType，存在两个候选Bean，但是我们其实希望ProgramTeacher这个Bean在任何情况下都不参与到自动装配中，此时我们就可以将它的自动装配候选关闭：</p>
<p><em>autowire-candidate&#x3D;”false”</em>&#x2F;&#x2F;关闭自动装配候选</p>
<p>当<code>autowire-candidate</code>设定false时，这个Bean将不再作为自动装配的候选Bean，此时自动装配候选就只剩下一个唯一的Bean了，报错消失，程序可以正常运行。</p>
<p>![[Pasted image 20240710215624.png]]</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ArtTeacher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ProgramTeacher&quot;</span> <span class="attr">autowire-</span>   <span class="attr">candidate</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这时候，就只有一个候选bean了，不会有歧义</p>
<p>![[Pasted image 20240710215750.png]]</p>
<ul>
<li>除了这种方式，<em>我们也可以设定primary属性，表示这个Bean作为主要的Bean，当出现歧义时，也会优先选择：</em></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ArtTeacher&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;teacher2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Service.Impl.ProgramTeacher&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样写程序<em>依然可以正常运行</em>，并且选择的也是ArtTeacher（就是不知道为什么IDEA会上红标，BUG？）<br>![[Pasted image 20240710220024.png]]</p>
<hr color="green">

<h2 id="2-5-生命周期和继承"><a href="#2-5-生命周期和继承" class="headerlink" title="2.5 生命周期和继承"></a>2.5 生命周期和继承</h2><h3 id="2-5-1生命周期"><a href="#2-5-1生命周期" class="headerlink" title="2.5.1生命周期"></a>2.5.1生命周期</h3><p>除了修改构造方法，我们也可以为Bean指定初始化方法和销毁方法，以便在对象创建和被销毁时执行一些其他的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;<span class="comment">//初始化方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;我是对象初始化时要做的事情！&quot;</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;<span class="comment">//销毁方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;我是对象销毁时要做的事情！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过<code>init-method</code>和<code>destroy-method</code>来指定：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Student&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">注意：init-method后面写对应的初始化方法名,destory-method后面写对应的销毁方法名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![[Pasted image 20240712160644.png]]</p>
<p>![[Pasted image 20240712160700.png]]</p>
<p><em>那么什么时候是初始化，什么时候又是销毁呢？</em></p>
<p><em>注意这里context是使用子类ClassPathXmlApplicationContext类型，而不是父类ApplicationContext<br>因为ApplicationContext没有close方法</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当容器创建时，默认情况下Bean都是单例的，那么都会在一开始就加载好，对象构造完成后，会执行init-method</span></span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;SpringConfig.xml&quot;</span>);  </span><br><span class="line">System.out.println(<span class="string">&quot;context要创建实例对象了&quot;</span>);  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> context.getBean(Student.class);  </span><br><span class="line">student.study();  </span><br><span class="line">System.out.println(<span class="string">&quot;context要销毁了&quot;</span>);  </span><br><span class="line"><span class="comment">//我们可以调用close方法关闭容器，此时容器内存放的Bean也会被一起销毁，会执行destroy-method</span></span><br><span class="line">context.close();<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>结果为：<br>可以发现，初始化方法是再创建context对象的时侯就调用了，而并非是在创建student对象的时候（这是在没有懒加载(lazy-init&#x3D;”false”)的情况<br>![[Pasted image 20240712161200.png]]</p>
<p>如果有懒加载（lazy-init&#x3D;”true”）</p>
<p>又会在context创建student对象的时候时候调用<br>![[Pasted image 20240712161459.png]]</p>
<p>说明：init方法的调用时刻取决于context的加载机制：</p>
<ul>
<li>单例模式是编译的时候就加载(会调用init), close的时候会调用destory</li>
<li>单例模式下，开启懒加载，就会用到的时候才会加载(会调用init),close会调用destory</li>
<li>原型模式下(多例模式)，用到的时候才会加载(会调用init)，close不会调用destory</li>
</ul>
<p><em>注意，如果Bean不是单例模式，而是采用的原型模式，那么就只会在获取时才创建，并调用init-method，而对应的销毁方法不会被调用</em><br>（<strong>因此，对于原型模式下的Bean，Spring无法顾及其完整生命周期，而在单例模式下，Spring能够从Bean对象的创建一直管理到对象的销毁</strong>）官方文档原文如下：</p>
<blockquote>
<p>In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean. The container instantiates, configures, and otherwise assembles a prototype object and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype beans hold. To get the Spring container to release resources held by prototype-scoped beans, try using a custom <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp">bean post-processor</a>, which holds a reference to beans that need to be cleaned up.</p>
</blockquote>
<h3 id="2-5-2-继承"><a href="#2-5-2-继承" class="headerlink" title="2.5.2 继承"></a>2.5.2 继承</h3><p>Bean之间也是具备继承关系的，只不过这里的继承并不是类的继承，而是属性的继承，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SportStudent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArtStudent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们先将ArtStudent注册一个Bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;artStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.ArtStudent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里我们会注入一个name的初始值，此时我们创建了一个SportStudent的Bean，我们希望这个Bean的属性跟刚刚创建的Bean属性是一样的，那么我们可以写一个一模一样的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;sportStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.SportStudent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span>//这里的name属性初始化为小明，很ArtStudent的一样</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不用继承，一个一个写<br>![[Pasted image 20240712163738.png]]<br>![[Pasted image 20240712163619.png]]</p>
<p><em>但是如果属性太多的话，是不是写起来有点麻烦？这种情况，我们就可以配置Bean之间的继承关系了，我们可以让SportStudent这个Bean直接继承ArtStudent这个Bean配置的属性：</em><br>(会把父bean的所有初始化号的值继承过来)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.SportStudent&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;artStudent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>用继承：<br>![[Pasted image 20240712163715.png]]</p>
<p>![[Pasted image 20240712163657.png]]</p>
<p>可以看到两种效果是一样的</p>
<p>这样，在ArtStudent Bean中配置的属性，会直接继承给SportStudent Bean（<em>注意，所有配置的属性，在子Bean中必须也要存在，并且可以进行注入，否则会出现错误</em>）</p>
<p><em>当然，如果子类中某些属性比较特殊，也可以在继承的基础上单独配置：</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;artStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.ArtStudent&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;sprotStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.SportStudent&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;artStudent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><em>如果我们只是希望某一个Bean仅作为一个配置模版供其他Bean继承使用，那么我们可以将其配置为abstract，这样，容器就不会创建这个Bean的对象了：</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;artStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.ArtStudent&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span>//作为模板使用</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.SportStudent&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;artStudent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>注意</em>，一旦声明为抽象Bean，那么就无法通过容器获取到其实例化对象了。</p>
<p><img src="https://image.itbaima.cn/markdown/2022/11/23/SyDkvOldB7ETW4z.png" alt="image-20221123140409416"></p>
<p>不过Bean的继承使用频率不是很高，了解就行。</p>
<p><em>这里最后再提一下，我们前面已经学习了各种各样的Bean配置属性，如果我们希望整个上下文中所有的Bean都采用某种配置，我们可以在最外层的beans标签中进行默认配置：</em></p>
<p><img src="https://image.itbaima.cn/markdown/2022/11/23/KzSUJXa4jBfO9rd.png" alt="image-20221123141221259"></p>
<p>这样，即使Bean没有配置某项属性，但是只要在最外层编写了默认配置，那么同样会生效，除非Bean自己进行配置覆盖掉默认配置。</p>
<hr color="green">

<h2 id="2-6-工厂模式和工厂Bean"><a href="#2-6-工厂模式和工厂Bean" class="headerlink" title="2.6 工厂模式和工厂Bean"></a>2.6 工厂模式和工厂Bean</h2><p>前面我们介绍了IoC容器的Bean创建机制，默认情况下，容器会调用Bean对应类型的构造方法进行对象创建，</p>
<p><em>但是在某些时候，我们可能不希望外界使用类的构造方法完成对象创建</em>，<br>比如在工厂方法设计模式中（详情请观看《Java设计模式》篇 视频教程）</p>
<p><em>我们更希望 Spring不要直接利用反射机制通过构造方法创建Bean对象，<br>而是利用反射机制先找到对应的工厂类，然后利用工厂类去生成需要的Bean对象：</em></p>
<ul>
<li><em>第一种：</em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    Student() &#123;<span class="comment">//Student构造方法不给权限，为了通过StudentFactory来获取Student对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我被构造了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title function_">getStudent</span><span class="params">()</span>&#123;<span class="comment">//这里为static方法，</span></span><br><span class="line">      	System.out.println(<span class="string">&quot;欢迎光临电子厂&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时Student有一个工厂，我们正常情况下需要使用工厂才可以得到Student对象，现在我们希望Spring也这样做，不要直接去反射搞构造方法创建，我们可以通过factory-method进行指定：</p>
<p><em>class里面写实体类工厂的名称，factory-method写工厂方法</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.StudentFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getStudent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，这里的Bean类型需要填写为Student类的工厂类，并且添加factory-method指定对应的工厂方法，<br><em>但是最后注册的是工厂方法的返回类型，所以说依然是Student的Bean：</em></p>
<p><img src="https://image.itbaima.cn/markdown/2022/11/23/5Id43xPneJiWfZs.png" alt="image-20221123143302785"></p>
<p>此时我们再去进行获取<br>(有些人觉得注册bean为StduentFactory，所以使用的时候写StudentFactory.class）<br>(其实不是，因为最后注册的bean还是Studentbean,所以context获取的是Student.class)，拿到的也是通过工厂方法得到的对象：</p>
<p>![[Pasted image 20240712170102.png]]</p>
<ul>
<li><em>这里有一个误区，千万不要认为是我们注册了StudentFactory这个Bean，class填写为这个类这个只是为了告诉Spring我们的工厂方法在哪个位置，真正注册的是工厂方法提供的东西。</em></li>
</ul>
<p>如果我们要的是StudentFactory.class,那么会报错：<br>![[Pasted image 20240712171403.png]]</p>
<p>*另外有个细节：</p>
<p><em>如果要像这么写：实体类的构造方法没有权限，要通过工厂类的get实体类来获取对象，那么对应的get实体类方法必须为static,不然就不能注册成功了：</em><br>![[Pasted image 20240712172028.png]]<br>![[Pasted image 20240712172047.png]]<br>就像这样，会找不到对应的获取实体类的方法<br>![[Pasted image 20240712172105.png]]</p>
<p><em>因为：<br>工厂类的getStudent方法不为static会报错，是因为在Spring框架中，当使用工厂方法（factory-method）时，需要指定一个静态方法作为工厂方法。这是因为Spring容器在初始化bean时，需要通过反射调用静态方法来创建实例。如果getStudent方法不是静态的，那么Spring容器无法直接访问它，从而导致错误。</em></p>
<p>如果就工厂类的获取实体类的方法不是static，也可以换一种方式，就是把先把工厂类注册为bean,再获取工厂类对象，通过工厂类对象来获取对应的实体类，（看下面）</p>
<hr>
<p>可以发现，当我们采用工厂模式后，我们就无法再通过配置文件对Bean进行依赖注入等操作了，而是只能在工厂方法中完成，这似乎与Spring的设计理念背道而驰？</p>
<ul>
<li><em>第二种：</em></li>
</ul>
<p>当然，可能某些工厂类需要构造出对象之后才能使用，我们也可以将某个工厂类直接注册为工厂Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudent</span><span class="params">()</span>&#123;<span class="comment">//这里getStudent不为static方法，之前的就行不通了，现在就只能先获取到Studentfactory对象，再调用getStudent方法来获取Student对象了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎光临电子厂&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在需要StudentFactory对象才可以获取到Student，此时我们就只能先将其注册为Bean了：</p>
<p><em>像这样将工厂类注册为Bean，我们称其为工厂Bean</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;studentFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.StudentFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时候，你就可以直接获取工厂对象，然后通过getStudent方法获取Student对象了<br>![[Pasted image 20240712174922.png]]<br>![[Pasted image 20240712174950.png]]</p>
<p>但是如果你还想把Student注册为bean</p>
<p>那么就再使用<code>factory-bean</code>来指定Bean的工厂Bean：<br>(这里就把student类也注册为bean了，并且studentbean是由这个工厂来生成的了)</p>
<p>注意，这里的getStudent就不能是static了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">factory-bean</span>=<span class="string">&quot;studentFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getStudent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>![[Pasted image 20240712174610.png]]<br>写在一起：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--getStudent不为static的情况--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--先把工厂类注册为bean--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;studentFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.StudentFactory&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--然后再使用`factory-bean`来指定Bean的工厂Bean，这个bean最后注册的还是最后想得到的东西的bean--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">factory-bean</span>=<span class="string">&quot;studentFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getStudent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这时候，我们就也可以直接通过Student.class来获取：</p>
<p>![[Pasted image 20240712175318.png]]<br>![[Pasted image 20240712175306.png]]</p>
<p>可以与之前getStudent为static的情况对比一下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--getStudent为static的情况--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.StudentFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getStudent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>是不是感觉差不多，就是非static就是把static的bean拆成两句了</p>
<p>![[Pasted image 20240708150855.png]]<br>![[Pasted image 20240708150910.png]]</p>
<p><img src="https://image.itbaima.cn/markdown/2022/11/23/ih1Af7xBdX3ebaG.png" alt="image-20221123164134470"></p>
<p>此时可以看到，工厂方法上同样有了图标，这种方式，由于工厂类被注册为Bean，此时我们就可以在配置文件中为工厂Bean配置依赖注入等内容了。</p>
<ul>
<li><p>**<em>当然相对于第二种，还有一种最标准的写法：</em></p>
</li>
<li><p><em>第三种：</em></p>
</li>
</ul>
<p>配置里可以只写这个<br>![[Pasted image 20240712175752.png]]</p>
<p>我们直接让工程类实现接口FactoryBean&lt;要产生的类型&gt;(如果是代码可改，而不是别人给我们提供的框架)</p>
<p>泛型里面写我们要生产的类型:这里为Student<br>![[Pasted image 20240712180027.png]]</p>
<p>然后实现两个方法：<br>getObject()和getObjectType()<br>![[Pasted image 20240712180115.png]]</p>
<p>![[Pasted image 20240712180642.png]]</p>
<p>最后可以看到：Student类也被注册为bean了:(是不是和第二种的效果一样了)</p>
<p>![[Pasted image 20240712180712.png]]</p>
<p>因为Student也被注册为Bean了，所以使用Student.class来获取对象就可以了<br>![[Pasted image 20240712180746.png]]</p>
<p>*这里还有一个很细节的操作(只适用于这个实现了接口的形式)，</p>
<p>如果我们想获取工厂Bean为我们提供的Bean(可以用StudentFactory.class，也可以适用bean的name)</p>
<ul>
<li><p>使用StudentFactory.class很正常，因为Studentfactory被注册为bean了</p>
</li>
<li><p><em>也可以直接输入工厂Bean的名称，但是这样不会得到工厂Bean的实例，而是工厂Bean生产的Bean的实例：</em></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">bean</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;studentFactory&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>![[Pasted image 20240712181228.png]]</p>
<p><em>当然，如果我们需要获取工厂类的实例，可以在名称前面添加<code>&amp;</code>符号：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StudentFactory</span> <span class="variable">bean</span> <span class="operator">=</span> (StudentFactory) context.getBean(<span class="string">&quot;&amp;studentFactory&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>![[Pasted image 20240712181245.png]]</p>
<p>又是一个小细节。</p>
<hr>
<p>好了，现在三种工厂模式的写法我们总结一下：</p>
<ul>
<li>*第一种：工厂类的get方法为static</li>
</ul>
<p>配置文件里面这么写：最后不会把工厂类注册为bean，而是会把工厂类生产的类型注册为bean<br>（只是把Student注册为bean,而不是把StudentFactory注册为bean）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.StudentFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getStudent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用：<br>由于工厂类没有注册为bean，就不能使用工厂类.class了(不然会报错)</p>
<p>应该使用Student.class<br>![[Pasted image 20240712170102.png]]</p>
<ul>
<li>*第二种：工厂类的get方法为非static</li>
</ul>
<p>直接将工厂注册为bean(工厂bean),然后指定工厂bean的工厂方法，<br>这样可以不仅可以把实体类注册为bean，也可以把工厂类注册为bean,<br>那么使用Student.class可以<br>使用StudentFactory.class也可以了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--getStudent不为static的情况--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--先把工厂类注册为bean--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;studentFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.StudentFactory&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--然后再使用`factory-bean`来指定Bean的工厂Bean，这个bean最后注册的还是最后想得到的东西的bean--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">factory-bean</span>=<span class="string">&quot;studentFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getStudent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>![[Pasted image 20240712182315.png]]</p>
<ul>
<li>*第三种：基于第二种(工厂类的get方法为非static),只把工厂类注册为bean，并且要让工厂类实现FactoryBean&lt;生产类型&gt;<br>(最后会把工厂类注册为bean,已经生产的实体类注册为bean)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--先把工厂类注册为bean--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;studentFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.test.StudentFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>实现FactoryBean接口:注意实现的两个方法的写法<br>![[Pasted image 20240712182624.png]]</p>
<p>与第二种的用法相同：（但是打印结果不太相同，是因为两种方式的运行机制不同）<br>![[Pasted image 20240712182717.png]]</p>
<p>*第三种方法还有个细节：</p>
<p>如果我们想获取工厂Bean为我们提供的Bean(可以用StudentFactory.class，也可以适用bean的name)</p>
<ul>
<li><p>使用StudentFactory.class很正常，因为Studentfactory被注册为bean了</p>
</li>
<li><p><em>也可以直接输入工厂Bean的名称，但是这样不会得到工厂Bean的实例，而是工厂Bean生产的Bean的实例：</em></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">bean</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;studentFactory&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>![[Pasted image 20240712181228.png]]</p>
<p><em>当然，如果我们需要获取工厂类的实例，可以在名称前面添加<code>&amp;</code>符号：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StudentFactory</span> <span class="variable">bean</span> <span class="operator">=</span> (StudentFactory) context.getBean(<span class="string">&quot;&amp;studentFactory&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>![[Pasted image 20240712181245.png]]</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://123asdasdnk.github.io">業火の 向日葵</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://123asdasdnk.github.io/2024/07/24/IOC%E5%AE%B9%E5%99%A8/Spring%E7%9A%84xml%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/">https://123asdasdnk.github.io/2024/07/24/IOC%E5%AE%B9%E5%99%A8/Spring%E7%9A%84xml%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://123asdasdnk.github.io" target="_blank">花火の绽放</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/IOC/">IOC</a></div><div class="post_share"><div class="social-share" data-image="/image/%E9%AC%BC%E5%88%80.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/24/IOC%E5%AE%B9%E5%99%A8/IoC%E7%90%86%E8%AE%BA%E4%BB%8B%E7%BB%8D/" title="IoC理论介绍"><img class="cover" src="/image/%E5%86%B2%E6%B5%AA.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IoC理论介绍</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/24/IOC%E5%AE%B9%E5%99%A8/Spring%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/" title="Spring注解使用"><img class="cover" src="/image/%E5%8A%A8%E6%BC%AB1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring注解使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/24/IOC%E5%AE%B9%E5%99%A8/Bean%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE/" title="Bean注册和配置"><img class="cover" src="/image/%E6%99%9A%E9%9C%9E.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">Bean注册和配置</div></div></a></div><div><a href="/2024/07/24/IOC%E5%AE%B9%E5%99%A8/IoC%E7%90%86%E8%AE%BA%E4%BB%8B%E7%BB%8D/" title="IoC理论介绍"><img class="cover" src="/image/%E5%86%B2%E6%B5%AA.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">IoC理论介绍</div></div></a></div><div><a href="/2024/07/24/IOC%E5%AE%B9%E5%99%A8/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/" title="使用注解开发"><img class="cover" src="/image/%E5%8A%A8%E6%BC%AB1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">使用注解开发</div></div></a></div><div><a href="/2024/07/24/IOC%E5%AE%B9%E5%99%A8/Spring%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/" title="Spring注解使用"><img class="cover" src="/image/%E5%8A%A8%E6%BC%AB1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">Spring注解使用</div></div></a></div><div><a href="/2024/07/24/IOC%E5%AE%B9%E5%99%A8/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" title="依赖注入"><img class="cover" src="/image/%E9%AC%BC%E5%88%80.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">依赖注入</div></div></a></div><div><a href="/2024/07/24/IOC%E5%AE%B9%E5%99%A8/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82Bean/" title="工厂模式和工厂Bean"><img class="cover" src="/image/%E5%86%B2%E6%B5%AA.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">工厂模式和工厂Bean</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">業火の 向日葵</div><div class="author-info__description">烟花绽放的瞬间，绚烂的是花火还是我们</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/123asdasdnk" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，请随便看看</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E7%BD%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">一、前置操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81xml%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">二、xml使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%BC%80%E5%A7%8B%E5%88%9B%E5%BB%BAApplicationContext"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 开始创建ApplicationContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Bean%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Bean注册和配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1%E5%AE%9E%E9%99%85%E4%B8%8A%E6%88%91%E4%BB%AC%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%BE%88%E5%A4%9A%E4%B8%AA%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%99%E4%BA%9B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9B%B8%E4%BA%92%E5%AF%BC%E5%85%A5%E7%9A%84%EF%BC%9A"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1实际上我们的配置文件可以有很多个，并且这些配置文件是可以相互导入的：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-bean%E6%B3%A8%E5%86%8C"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 bean注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3%E9%82%A3%E4%B9%88%E7%8E%B0%E5%9C%A8%E5%8F%88%E6%9C%89%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BA%86%EF%BC%8CIoC%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E7%9A%84Bean%E6%98%AF%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BF%98%E6%98%AF%E6%AF%8F%E6%AC%A1%E7%B4%A2%E8%A6%81%E7%9A%84%E6%97%B6%E5%80%99%E9%83%BD%E4%BC%9A%E7%BB%99%E6%88%91%E4%BB%AC%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%9F%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E5%9C%A8%E4%B8%BB%E6%96%B9%E6%B3%95%E4%B8%AD%E8%BF%9E%E7%BB%AD%E8%8E%B7%E5%8F%96%E4%B8%A4%E6%AC%A1Bean%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3那么现在又有新的问题了，IoC容器创建的Bean是只有一个还是每次索要的时候都会给我们一个新的对象？我们现在在主方法中连续获取两次Bean对象：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-Setter%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E5%9C%A8set%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 Setter依赖注入(在set方法里面进行初始化变量)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E5%B0%B1%E6%98%AF%E5%9C%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 构造方法依赖注入(就是在构造方法中初始化变量)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 自动装配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 生命周期和继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.5.2 继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82Bean"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 工厂模式和工厂Bean</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/24/Spring%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%9B%91%E5%90%AC%E5%99%A8/" title="监听器"><img src="/image/%E6%B5%B7.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="监听器"/></a><div class="content"><a class="title" href="/2024/07/24/Spring%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%9B%91%E5%90%AC%E5%99%A8/" title="监听器">监听器</a><time datetime="2024-07-23T16:29:30.798Z" title="发表于 2024-07-24 00:29:30">2024-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/24/Spring%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" title="任务调度"><img src="/image/%E5%86%B2%E6%B5%AA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="任务调度"/></a><div class="content"><a class="title" href="/2024/07/24/Spring%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" title="任务调度">任务调度</a><time datetime="2024-07-23T16:29:30.798Z" title="发表于 2024-07-24 00:29:30">2024-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/24/Spring%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Aware%E7%B3%BB%E5%88%97%E6%8E%A5%E5%8F%A3/" title="Aware系列接口"><img src="/image/%E5%86%B2%E6%B5%AA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Aware系列接口"/></a><div class="content"><a class="title" href="/2024/07/24/Spring%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Aware%E7%B3%BB%E5%88%97%E6%8E%A5%E5%8F%A3/" title="Aware系列接口">Aware系列接口</a><time datetime="2024-07-23T16:29:30.796Z" title="发表于 2024-07-24 00:29:30">2024-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/24/SqEL%E5%85%A5%E9%97%A8/%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5/" title="外部属性注入"><img src="/image/%E9%AC%BC%E5%88%80.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="外部属性注入"/></a><div class="content"><a class="title" href="/2024/07/24/SqEL%E5%85%A5%E9%97%A8/%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5/" title="外部属性注入">外部属性注入</a><time datetime="2024-07-23T16:24:28.241Z" title="发表于 2024-07-24 00:24:28">2024-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/24/SqEL%E5%85%A5%E9%97%A8/%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95/" title="集合操作相关语法"><img src="/image/%E5%86%B2%E6%B5%AA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="集合操作相关语法"/></a><div class="content"><a class="title" href="/2024/07/24/SqEL%E5%85%A5%E9%97%A8/%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95/" title="集合操作相关语法">集合操作相关语法</a><time datetime="2024-07-23T16:24:28.241Z" title="发表于 2024-07-24 00:24:28">2024-07-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 業火の 向日葵</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>